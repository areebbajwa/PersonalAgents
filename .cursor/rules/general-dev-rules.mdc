---
description: 
globs: 
alwaysApply: false
---
## Core Development Philosophy

### 1. **Test-Driven Development (TDD)**
- Always use TDD when refactoring or building complex functionality
- Create comprehensive todo lists first after investigating current functionality
- Test everything before considering work complete
- Only run the specific tests that failed last time to save time - full test suites take too long

### 2. **Aggressive Simplification & Cleanup**
- When systems become too complex, refactor and simplify rather than adding more complexity
- **NEVER** create fallbacks, maintain legacy code, or keep backward compatibility
- Remove legacy code completely - don't leave any behind, no matter how much existing code depends on it
- Delete old, failed experiments and obsolete implementations immediately
- Clean up old mess as you go - every change should leave the codebase cleaner than before
- Prefer unified approaches over fragmented solutions
- Use batch operations and efficient APIs instead of multiple separate calls when possible
- Break things if necessary to achieve clean architecture - force dependent code to update

### 3. **Real-World Testing Required**
- Code is not considered complete until actually tested with real tasks
- "It's not completed until you test it!"
- Test with actual functionality, not just imports or basic setup
- Use debugging and logging when issues are unclear

## Development Process Rules

### 4. **Process Management**
- **NEVER** start background terminals or background tasks
- For long-running processes, use foreground processes that output to a file
- All processes should be visible and monitorable by the user
- Ensure process output is captured and accessible for debugging

### 5. **Documentation and README Requirements**
- Include comprehensive README files with clear instructions
- Document all learnings and previous attempts in todo lists to avoid repeating mistakes
- Update todo lists throughout development to track what has been tried
- Include all necessary setup steps and dependencies

### 6. **Learning and Iteration Management**
- Maintain comprehensive todo lists that track both current tasks and past attempts
- Document what has been tried and failed, including why it didn't work
- Update todo lists continuously with learnings to avoid repeating mistakes
- Include specific details about failed approaches so they can be avoided in future iterations
- Reference previous attempts when considering new approaches

### 7. **Persistence and State Management**
- Prefer persistent solutions that maintain state across sessions
- Reuse existing instances/connections rather than recreating them
- Store data appropriately and consider storage limitations
- Auto-activate necessary environments when needed

## Code Quality Standards

### 8. **Error Handling and Debugging**
- Add debug logging when issues are unclear
- Ensure processes don't hang indefinitely due to unhandled errors
- Provide clear error messages but **NO** fallback options - force proper fixes
- Log to files when appropriate for debugging
- **NEVER** implement workarounds or temporary fixes that become permanent

### 9. **Architecture Patterns**
- Create unified data structures instead of separate logic paths for similar functionality
- Prefer single services handling related functionality over scattered logic across multiple files
- Use clear separation of concerns (data fetching vs. processing vs. business logic)
- Make systems modular and easily updatable
- **Ruthlessly delete** duplicate or similar functionality - consolidate everything into single implementations

## Development Workflow

### 10. **Research and Implementation**
- Search the web for best practices when unsure of the correct approach
- Don't make assumptions - verify the proper way to implement solutions
- Learn from existing implementations before creating custom solutions

### 11. **Configuration Management**
- Store configuration in environment files with clear naming conventions
- Keep sensitive data out of version control
- Use consistent patterns for configuration across projects

## Project Management

### 12. **Aggressive File Organization & Cleanup**
- **Immediately delete** failed experiments and obsolete code - don't leave them in the codebase
- Remove entire directories of old approaches if they're no longer needed
- Maintain clean project structure and address recurring issues by eliminating their root causes
- **Never** keep "just in case" code - if it's not actively used, delete it
- Clean up imports, unused functions, and dead code paths continuously

### 13. **Version Control**
- Check status regularly and maintain clean working directory
- Delete persistent untracked files that aren't needed
- Commit frequently to avoid losing cleanup progress

## Performance and Efficiency

### 14. **Optimization Principles**
- Batch operations whenever possible instead of individual calls
- Utilize available resources efficiently (large context windows, connection pooling, etc.)
- Avoid duplicate operations - reuse cached data when possible
- Consider resource limits and structure operations efficiently
- **Delete** inefficient implementations rather than optimizing them - start fresh with better approaches

## Quality Assurance

### 15. **Real-World Validation**
- Test with actual user data and scenarios
- Verify that outputs contain proper content (not generic error responses)
- Check that all functionality works end-to-end before considering complete
- Use appropriate testing methods for verification (manual testing, snapshots, etc.)

### 16. **Environment and Dependencies**
- Auto-start required environments (virtual environments, containers, etc.)
- Ensure all dependencies are properly installed and configured
- Test that tools work in isolation and integrated environments
- **Remove** unused dependencies and clean up requirements files regularly

## Core Cleanup Principles

### 17. **No Compromise on Cleanliness**
- **NEVER** implement backward compatibility layers
- **NEVER** create fallback mechanisms for old code
- **NEVER** maintain deprecated functionality "just in case"
- If old code breaks due to cleanup, fix it properly or delete it entirely
- Every development session should result in a net reduction of code complexity
- Delete first, implement second - remove the old mess before building the new solution
