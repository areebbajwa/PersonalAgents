---
description: dev mode workflow - simplified step-by-step process
globs: 
alwaysApply: false
---

# DEV MODE WORKFLOW: Step-by-Step Development Process

## WORKFLOW: Development Tasks

### STEP 1: Announce Dev Mode
**MANDATORY first response**
```
⚡ **DEV MODE ACTIVATED**

I'm operating under DEV MODE rules: Simplify ruthlessly, test what matters, and create modern, maintainable code.
```

### STEP 2: Start Git Workflow
**IMMEDIATELY for any code changes**
1. Create branch:
   ```bash
   git checkout -b claude-session-YYYYMMDD-[topic]
   git push -u origin claude-session-YYYYMMDD-[topic]
   ```
2. Optional: Create draft PR if complex feature

### STEP 3: Consult Knowledge Base
**Before writing ANY code**
1. Check `LEARNINGS.md` for proven patterns
2. Search codebase for similar implementations
3. Find existing code to reuse/extend
4. Check official API docs for batch operations

### STEP 4: Apply Musk's 5-Step Process
**Question → Delete → Simplify**
1. **Question**: Is this requirement necessary?
2. **Delete**: What can we remove?
3. **Simplify**: How can we make it simpler?
4. **Accelerate**: Speed up only after simplifying
5. **Automate**: Automate only proven processes

Example:
- User wants caching → Do ALL endpoints need it?
- Can we use in-memory instead of Redis?
- Test the simple solution first

### STEP 5: Plan with Test Gates
**Create incremental plan**
```
Plan:
1. Build feature A
2. Write E2E test for A
3. **TEST GATE**: Run test - MUST PASS
4. Only then: Build feature B
5. Write E2E test for B
6. **TEST GATE**: Run test - MUST PASS
```

### STEP 6: Implement One Piece at a Time
**Never move forward until tests pass**
1. Write one logical unit of functionality
2. Write E2E test for that functionality
3. Run test in background:
   ```bash
   npm test feature_a.test.js > test.log 2>&1 &
   sleep 30 && tail -n 100 test.log
   ```
4. Mark test status: `✓ test_feature_a - PASSED at 10:32am`
5. ONLY if passed → Move to next feature

### STEP 6: Use Batch Operations
**Research batch APIs first**
```python
# ❌ NEVER
for item in items:
    api.update(item)  # 100 calls!

# ✅ ALWAYS  
api.batch_update(items)  # 1 call!
```

### STEP 7: Track Test Status
**Avoid redundant test runs**
```
Test Tracking:
✓ test_user_registration.py - PASSED at 10:32am
✓ test_user_login.py - PASSED at 10:45am
⏸ test_password_reset.py - Working now
```
- Don't re-run passed tests until final verification
- Track what's already proven to work

### STEP 8: Commit with Test Status
**After each feature is complete and tested**
1. Stage changes: `git add -A`
2. Commit with test results:
   ```bash
   git commit -m "feat: add X - tests: 5/5 passed"
   git commit -m "fix: resolve Y - e2e tests: 3/3 passed"
   git commit -m "refactor: optimize Z - unit tests: 45/45 passed"
   ```
3. Push after 3-5 commits: `git push origin HEAD`

### STEP 9: Final Verification
**Before marking complete**
1. Run full test suite ONCE
2. All tests must pass
3. Update `LEARNINGS.md` with new patterns
4. Final commit and push

## QUICK REFERENCE

### Commit Prefixes
- `feat`: New feature
- `fix`: Bug fix
- `refactor`: Code refactoring
- `docs`: Documentation
- `test`: Test changes
- `chore`: Maintenance
- `style`: Formatting

### File Operations
- NEVER create files unless necessary
- ALWAYS prefer editing existing files
- NO proactive documentation creation

### Terminal Commands
- Max 2-minute timeout
- Background execution: `cmd > log.txt 2>&1 &`
- Check progress: `sleep 10 && tail -n 50 log.txt`
- Max sleep: 119 seconds
- Never use `tail -f` or `watch`

### Testing Priority
✅ **High-Value Tests**:
- E2E tests of critical flows
- Tests against live services
- Business logic validation

❌ **Skip These Tests**:
- Framework functionality
- Simple getters/setters
- UI component rendering

### Documentation Rules
- Update docs when user gives feedback
- Create new docs ONLY when asked
- Document in LEARNINGS.md what works
- Never create README proactively

### Error Handling
- NO fallbacks that hide problems
- NO workarounds or temp fixes
- Fix bugs immediately
- Add clear debug logging

### Key Principles
1. **Simplify Ruthlessly**: Delete before optimizing
2. **Test Gates**: Never proceed with failing tests
3. **Batch Everything**: Always use batch APIs
4. **Learn and Reuse**: Check LEARNINGS.md first
5. **Track Progress**: Know which tests passed

### Emergency Procedures
**Rollback**: 
```bash
git reset --hard [commit-hash]
git push --force-with-lease origin HEAD
```

**Session Recovery**:
1. `git branch --show-current`
2. `git status`
3. Run tests
4. Continue with commits

## WORKFLOW CHECKLIST

Before starting any task:
- [ ] Announced DEV MODE
- [ ] Created git branch
- [ ] Checked LEARNINGS.md
- [ ] Searched for existing code
- [ ] Applied 5-step process
- [ ] Created test-gated plan

During development:
- [ ] One feature at a time
- [ ] E2E test before moving on
- [ ] Using batch operations
- [ ] Tracking test status
- [ ] Not re-running passed tests
- [ ] Committing with test status
- [ ] Pushing every 3-5 commits

Before completion:
- [ ] All tests passing
- [ ] LEARNINGS.md updated
- [ ] No code duplication
- [ ] Clean, simple solution