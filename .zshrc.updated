export ANDROID_HOME=/Volumes/ExtremeSSD/android_studio_sdk
export PATH=$PATH:$ANDROID_HOME/platform-tools
alias index='/Volumes/ExtremeSSD/KalaamParent/.venv/bin/index'

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# bun completions
[ -s "/Users/areeb2/.bun/_bun" ] && source "/Users/areeb2/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Volumes/ExtremeSSD/KalaamParent/KalaamHelpers/gcloud_sdk_temp/google-cloud-sdk/path.zsh.inc' ]; then . '/Volumes/ExtremeSSD/KalaamParent/KalaamHelpers/gcloud_sdk_temp/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/Volumes/ExtremeSSD/KalaamParent/KalaamHelpers/gcloud_sdk_temp/google-cloud-sdk/completion.zsh.inc' ]; then . '/Volumes/ExtremeSSD/KalaamParent/KalaamHelpers/gcloud_sdk_temp/google-cloud-sdk/completion.zsh.inc'; fi
export PATH="$HOME/.local/bin:$PATH"
alias python=python3.10
export PATH="/Users/areeb2/.nvm/versions/node/v22.15.1/bin:/Users/areeb2/.local/bin:/Users/areeb2/.bun/bin:/Users/areeb2/.nvm/versions/node/v22.15.1/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/Little Snitch.app/Contents/Components:/Volumes/ExtremeSSD/android_studio_sdk/platform-tools"
export PATH="/Users/areeb2/.nvm/versions/node/v22.15.1/bin:/Users/areeb2/.local/bin:/Users/areeb2/.bun/bin:/Users/areeb2/.nvm/versions/node/v22.15.1/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/Little Snitch.app/Contents/Components:/Volumes/ExtremeSSD/android_studio_sdk/platform-tools" # for zsh

# Show hidden files by default
alias ls='ls -la'
alias ll='ls -la'
alias la='ls -la'

# Add ~/bin to PATH for custom scripts
export PATH="$HOME/bin:$PATH"

# Screen tools directory
# Use local copy for SSH sessions, external drive for local sessions
if [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" ]]; then
    SCREEN_TOOLS="$HOME/screen-tools-local"
else
    SCREEN_TOOLS="/Volumes/ExtremeSSD/PersonalAgents/PersonalAgents/cli_tools/screen-tools"
fi

# Screen management aliases
alias sn="$SCREEN_TOOLS/screen-new"          # Start new screen session
alias sl="$SCREEN_TOOLS/screen-list"         # List all screen sessions
alias sa="$SCREEN_TOOLS/screen-attach"       # Attach to screen session
alias sr="$SCREEN_TOOLS/screen-recent"       # Attach to most recent screen session
alias sd="$SCREEN_TOOLS/screen-detach"       # Detach from current session
alias sk="$SCREEN_TOOLS/screen-kill"         # Kill a screen session
alias ska="$SCREEN_TOOLS/screen-killall"     # Kill all screen sessions except current

# Terminal output logging setup for ai-monitor (manual activation)
# This avoids interfering with applications like Claude that need stdin
if [[ -n "$TMUX" && -z "$TERMINAL_LOG_SETUP" ]]; then
    # Create terminal logs directory
    mkdir -p ~/.terminal-logs
    
    # Generate log filename based on tmux session
    TMUX_SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null || echo "unknown")
    LOG_FILE="$HOME/.terminal-logs/terminal-${TMUX_SESSION_NAME}-$(date +%Y%m%d-%H%M%S).log"
    
    # Export log file path for reference
    export TERMINAL_LOG_FILE="$LOG_FILE"
    export TERMINAL_LOG_SETUP=1
    
    # Create a symlink to the latest log for easy access
    ln -sf "$LOG_FILE" "$HOME/.terminal-logs/latest-${TMUX_SESSION_NAME}.log"
    
    # Function to start logging
    start_terminal_log() {
        echo "[Terminal logging started: $(date)]" >> "$TERMINAL_LOG_FILE"
        echo "Session: $TMUX_SESSION_NAME" >> "$TERMINAL_LOG_FILE"
        echo "Directory: $(pwd)" >> "$TERMINAL_LOG_FILE"
        echo "---" >> "$TERMINAL_LOG_FILE"
        
        # Use exec redirection to capture all output
        exec > >(tee -a "$TERMINAL_LOG_FILE") 2>&1
        export TERMINAL_LOG_ACTIVE=1
        echo "âœ… Terminal logging activated"
    }
    
    # Alias for convenience
    alias tlog='start_terminal_log'
    
    # Quietly set up logging - no output
fi

# Quick screen command - start screen named after current directory
alias sq="$SCREEN_TOOLS/screen-quick"        # Quick screen in current dir

# Quick screen commands
alias screen-resume='screen -r'     # Resume detached session
alias screen-shared='screen -x'     # Share session (multi-display)
alias screen-wipe='screen -wipe'    # Clean up dead sessions
alias sh="$SCREEN_TOOLS/screen-help"             # Show screen help
alias screen-cleanup="$SCREEN_TOOLS/screen-cleanup" # Clean up old detached sessions

# Auto-start tmux session for new terminals
# To disable: set DISABLE_AUTO_TMUX=1 in your environment
if [[ -z "$TMUX" && -z "$DISABLE_AUTO_TMUX" && $- == *i* ]]; then
    # For SSH connections, show available sessions but don't auto-start
    if [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" ]]; then
        echo "ðŸ“º Available tmux sessions:"
        tmux ls 2>/dev/null || echo "No sessions"
        echo ""
        echo "ðŸ’¡ Use 'tmux attach -t <name>' to attach to a session"
    else
        # For local terminals, create a session named after the current directory
        # Get the current directory name (handle home directory specially)
        if [[ "$PWD" == "$HOME" ]]; then
            DIR_NAME="home"
        else
            DIR_NAME=$(basename "$PWD")
        fi
        
        # Clean the directory name (remove special chars, truncate if too long)
        CLEAN_DIR=$(echo "$DIR_NAME" | sed 's/[^a-zA-Z0-9_-]/-/g' | cut -c1-20)
        
        # If we ended up with empty or just dash, use "term"
        if [[ -z "$CLEAN_DIR" || "$CLEAN_DIR" == "-" ]]; then
            CLEAN_DIR="term"
        fi
        
        # Generate unique suffix (last 4 chars of terminal ID or random)
        if [[ -n "$TERM_SESSION_ID" ]]; then
            # macOS Terminal.app provides a unique session ID
            SUFFIX="${TERM_SESSION_ID: -4}"
        else
            # Fallback: use random 4 digits
            SUFFIX=$((RANDOM % 9000 + 1000))
        fi
        
        # Combine directory name with unique suffix
        SESSION_NAME="${CLEAN_DIR}-${SUFFIX}"
        
        echo "ðŸ“º Starting tmux session '${SESSION_NAME}' in $(pwd)"
        echo "   Directory: $DIR_NAME â†’ Session: $SESSION_NAME"
        
        # Export session name for terminal logging
        export TERMINAL_SESSION_NAME="$SESSION_NAME"
        
        # Start tmux with the session name
        exec tmux new-session -s "${SESSION_NAME}" -c "$PWD"
    fi
    
    # Clean up old detached tmux sessions on startup
    tmux_cleanup_old_sessions
fi
export PATH=$PATH:$HOME/.maestro/bin
# Function to run claude with terminal logging and worktree setup
yolo() {
    # Parse optional project name argument
    local PROJECT_NAME="${1:-}"
    
    # If we're not already in a worktree and project name is provided
    if [[ -n "$PROJECT_NAME" ]] && [[ ! "$PWD" =~ "/worktrees/" ]]; then
        # Create worktree for the project
        local WORKTREE_DATE=$(date +%Y%m%d)
        local WORKTREE_DIR="worktrees/${PROJECT_NAME}-${WORKTREE_DATE}"
        
        # Check if we're in a git repository
        if git rev-parse --git-dir > /dev/null 2>&1; then
            echo "Creating worktree for project: $PROJECT_NAME"
            
            # Create worktrees directory if it doesn't exist
            mkdir -p worktrees
            
            # Check if worktree already exists
            if [[ -d "$WORKTREE_DIR" ]]; then
                echo "Worktree already exists, using: $WORKTREE_DIR"
                cd "$WORKTREE_DIR"
            else
                # Create new worktree
                git worktree add "$WORKTREE_DIR" -b "${PROJECT_NAME}-${WORKTREE_DATE}" || {
                    echo "Failed to create worktree. Using current directory."
                }
                cd "$WORKTREE_DIR"
                
                # Push the new branch to origin
                git push -u origin "${PROJECT_NAME}-${WORKTREE_DATE}" 2>/dev/null || true
            fi
        else
            echo "Not in a git repository. Starting Claude in current directory."
        fi
    fi
    
    if [[ -n "$TERMINAL_LOG_FILE" ]]; then
        echo "[Claude session started: $(date)]" >> "$TERMINAL_LOG_FILE"
        echo "Directory: $(pwd)" >> "$TERMINAL_LOG_FILE"
        echo "---" >> "$TERMINAL_LOG_FILE"
        
        # Use script command to log the session (quiet mode)
        script -q -a "$TERMINAL_LOG_FILE" /Users/areeb2/.claude/local/claude --dangerously-skip-permissions
        
        echo "[Claude session ended: $(date)]" >> "$TERMINAL_LOG_FILE"
        echo "---" >> "$TERMINAL_LOG_FILE"
    else
        # Fallback if not in screen
        claude --dangerously-skip-permissions
    fi
}
export PATH=$PATH:$HOME/.maestro/bin
alias workflow-cli='/Volumes/ExtremeSSD/PersonalAgents/PersonalAgents/cli_tools/workflow-cli/workflow-cli.py'


# Keep screen's working directory in sync with the shell
# This ensures new screen windows open in the current directory
if [[ -n "$STY" ]]; then
    precmd() {
        screen -X chdir "$PWD"
    }
fi

alias claude="/Users/areeb2/.claude/local/claude"

# Screen logging tools
alias screen-log-view='~/PersonalAgents/cli_tools/screen-tools/screen-log-view'
alias screen-log-cleanup='~/PersonalAgents/cli_tools/screen-tools/screen-log-cleanup'

# Tmux shortcuts
# tr - attach to most recent tmux session
tr() {
    # Get the most recently active tmux session
    local recent_session=$(tmux list-sessions -F '#{session_last_attached} #{session_name}' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
    
    if [[ -z "$recent_session" ]]; then
        echo "No tmux sessions found"
        return 1
    fi
    
    # Check if we're already in a tmux session
    if [[ -n "$TMUX" ]]; then
        echo "Already in tmux session. Use 'tmux switch-client -t $recent_session' to switch."
        return 1
    fi
    
    echo "Attaching to most recent session: $recent_session"
    tmux attach-session -t "$recent_session"
}

# Auto-cleanup old detached tmux sessions (24+ hours inactive)
tmux_cleanup_old_sessions() {
    local current_time=$(date +%s)
    local max_age=$((24 * 60 * 60))  # 24 hours in seconds
    
    # Only run if tmux server is running
    if ! tmux ls >/dev/null 2>&1; then
        return
    fi
    
    # Get all detached sessions with their activity times
    tmux list-sessions -F '#{session_attached} #{session_activity} #{session_name}' 2>/dev/null | while read attached activity name; do
        # Skip attached sessions (attached=1)
        if [[ "$attached" == "1" ]]; then
            continue
        fi
        
        # Calculate age
        local age=$((current_time - activity))
        
        # Kill if older than 24 hours
        if [[ $age -gt $max_age ]]; then
            echo "Cleaning up old tmux session: $name (inactive for $((age / 3600)) hours)"
            tmux kill-session -t "$name" 2>/dev/null
        fi
    done
}
